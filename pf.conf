#       $OpenBSD: pf.conf,v 1.2 2015/05/18 16:04:21 reyk Exp $
#
# See pf.conf(5) for syntax and examples.
# Remember to set net.inet.ip.forwarding=1 and/or net.inet6.ip6.forwarding=1
# in /etc/sysctl.conf if packets are to be forwarded between interfaces.

# Macros - https://www.openbsd.org/faq/pf/macros.html#macros
#-----------------------
#  Macros are an alias for something you want to use in a rule.
#  Macros may contain a list of entries (enclosed in curly braces) e.g. webserver = { http, https }
#  A list simplifies rules that apply across multiple services/IPs/subnets etc.
#  Macros are referred to later with a prepended dollar sign, e.g. allow in proto tcp to any port $webserver
#  Macros that aren't referenced by a rule aren't used, so don't worry too much about the clutter here
#  If you aren't using the device for NAT, DHCP, or as a gateway most of these don't matter

# Interfaces - run ifconfig to obtain the aliases for your box
#  You should declare all your interfaces. That way you can update them if drivers/devices change
lan = "em1"  # LAN port on dual ethernet NIC
wan = "em0"  # WAN port on dual ethernet NIC
wlan = "wl0" # Wifi device

# Subnets
lan_net = "{ 192.168.0.0/16, 172.16.0.0/12, 10.0.0.0/8, fd00::/8 }" # LAN networks. You should trim this to only your network(s)
# Example - separate subnets on LAN (e.g. guest network):
users = "10.1.1.0/32"
gameconsoles = "10.1.2.0/32" # Subnet for game consoles - can prioritize bandwidth
smarthome = "10.1.3.0/32"    # Subnet for smart devices (TV/Printer/etc) - allows bandwidth prioritization and access restriction
guests = "10.1.4.0/32"       # Separate guests from access to user devices
# Example - multi-site VPN:
all_sites = "10.0.0.0/8" # Subnet(s) for all sites in VPN
site_1 = "10.1.0.0/16"   # Subnet(s) for first site
site_2 = "10.2.0.0/16"   # Subnet(s) for second site

# IPs
# Local IPs - these will rarely be required
dhcp_server = "10.1.0.1"
dns_server = "10.1.0.1"
# Static IPs from the web (generally useful for site-to-site VPN)
site_1_ipv4 = "123.045.067.089"
site_2_ipv4 = "123.045.067.090"
vpn_servers = "{ $site_1_ipv4, $site_2_ipv4 }"

# Services
# Use this space to declare services not found in /etc/services, or to create lists of services
mosh = "60000:61000" # Note mosh is a UDP protocol
logins = "{ ssh }"   # List of login services -- special rules for bruteforce
webserver = "{ http, https, ftp, sftp }" # An example of another service list with multiple services
ephem = "49152:65535" # The range of ephemeral ports - restrict LAN access to this range at your own peril
udp_log_ports = "{ 0:65535 }" # Reduce the range if resources won't allow
tcp_log_ports = "{ 0:65535 }" # Reduce the range if resources won't allow

# An example for how you may wish to use ephemeral ports is as follows:
#block from $smarthome to $users            # Block promiscuous smarthome devices
#pass from $smarthome to $users port $ephem # Allow services e.g. Chromecast -- I need to review if this is necessary, Chromecast may only require an outbound request from $users which is still permitted
# It won't do a great deal for security, but will separate an infected smart device from reaching assigned services, such as ssh


# Default settings
#-----------------------

# increase default state limit from 10'000 states on busy systems
#set limit states 100000

set skip on lo

# filter rules and anchor for ftp-proxy(8)
#anchor "ftp-proxy/*"
#pass in quick inet proto tcp to port ftp divert-to 127.0.0.1 port 8021

# anchor for relayd(8)
#anchor "relayd/*"
 
block return    # block stateless traffic
pass            # establish keep-state
 
# rules for spamd(8)
#table <spamd-white> persist
#table <nospamd> persist file "/etc/mail/nospamd"
#pass in on egress inet proto tcp from any to any port smtp \
#    divert-to 127.0.0.1 port spamd
#pass in on egress proto tcp from <nospamd> to any port smtp
#pass in log on egress proto tcp from <spamd-white> to any port smtp
#pass out log on egress proto tcp to any port smtp


#block in quick from urpf-failed to any # use with care

# By default, do not permit remote connections to X11
block return in on ! lo0 proto tcp to port 6000:6010

# Tables - http://www.openbsd.org/faq/pf/tables.html
#-----------------------
# Persistent tables continue after reboot
table <abuse> persist      # Abusive users - possibly not mailicious but worth limiting
table <malicious> persist  # Suspected malicious IPs - ban for some period of time
table <lan_brute>          # Suspected bruteforce from within the LAN
table <fail2ban> persist   # Table for fail2ban - https://github.com/fail2ban/fail2ban

# Rules - http://www.openbsd.org/faq/pf/filter.html
#-----------------------
# Note that rules are processed according to last match in file, unless the "quick" parameter is set for a given match
# Always put default policies up top and override rules either at the bottom or quick

# Default policies
#  These rules define the behavior if no other rule is encountered
block in # Default to block all inbound traffic
block in log proto udp on port $udp_log_ports # Log listed ports
block in log proto tcp on port $tcp_log_ports # Log listed ports

# Quick blocks
block quick from <malicious>
block quick from <lan_brute>
block quick from <fail2ban>

# Ports explicitly allowed in
#  backslash '\' is for line continuation
#  Since you can't do inline comments in line continuation I'm going to provide a commented example rule here
#pass in proto tcp on port ssh \ # Allow inbound traffic via tcp to ssh service port
#synproxy state \ # Synproxy is a fast tool to respond to syn requests, can prevent syn flood. State monitoring is required to limit connection rate
#(max 100, \ # Limit concurrent instances to 100 maximum
#source-track rule, \ # Count states created by this rule, as opposed to globally
#max-src-states 2, \ # Only allow two connections per IP
#max-src-conn-rate 10/2, \ # Don't allow any single IP to initiate traffic through this rule faster than 10 requests per 2 seconds
#overload <malicious> flush global) # If they exceed the connection rate add them to the <malicious> table and close all global requests from them
# Note that any reasonable max-src-conn-rate setting will leave you open to a slow bruteforce attempt. For full safety use something like fail2ban.

# Mosh
pass in proto udp on port $mosh

# Logins from the internet (multiple connections per second are probably from malicious attackers)
pass in proto tcp on port $logins \
synproxy state \
(source-track rule, max-src-conn-rate 10/2, \
overload <malicious> flush global)

# Logins from LAN (must be after logins rule)
#  You should add a chron job to clear the list on a regular basis so that you don't cut off LAN users
#  An example command for clearing old entries from a table is: pfctl -t lan_brute -T expire 3600
#   You can clear old entries of any table from a chron job this way
pass in proto tcp from $lan_net on port $logins \
synproxy state \
(source-track rule, max-src-conn-rate 10/2 \
overload <lan_brute> flush global)

# Webserver rules
#  Note that you should set generous limits; a single web request can pull several elements including .css, images, scripts, etc.
#  Also note that a non-malicious user may instantiate too many connections by using a download accelerator
#   In response to a download accelerator you may not want to ban the user but limit their bandwidth
pass in proto tcp on port $webserver \
synproxy state \
(max 10000, source-track rule, max-src-states 200, \
max-src-conn-rate 200/1, overload <abuse>)

#


